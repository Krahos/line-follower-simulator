#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2024::*;
#[macro_use]
extern crate std;
use wasmtime::component::bindgen;
use crate::{
    motors::MotorPower,
    sensors::{
        AsyncSensorResult, AsyncVoidResult, FutureHandle, ReadError, SensorIndexRange,
        SensorKind, SensorValues, TimeUs,
    },
};
/// Auto-generated bindings for a pre-instantiated version of a
/// component which implements the world `line-follower-robot`.
///
/// This structure is created through [`LineFollowerRobotPre::new`] which
/// takes a [`InstancePre`](wasmtime::component::InstancePre) that
/// has been created through a [`Linker`](wasmtime::component::Linker).
///
/// For more information see [`LineFollowerRobot`] as well.
pub struct LineFollowerRobotPre<T: 'static> {
    instance_pre: wasmtime::component::InstancePre<T>,
    indices: LineFollowerRobotIndices,
}
impl<T: 'static> Clone for LineFollowerRobotPre<T> {
    fn clone(&self) -> Self {
        Self {
            instance_pre: self.instance_pre.clone(),
            indices: self.indices.clone(),
        }
    }
}
impl<_T: 'static> LineFollowerRobotPre<_T> {
    /// Creates a new copy of `LineFollowerRobotPre` bindings which can then
    /// be used to instantiate into a particular store.
    ///
    /// This method may fail if the component behind `instance_pre`
    /// does not have the required exports.
    pub fn new(
        instance_pre: wasmtime::component::InstancePre<_T>,
    ) -> wasmtime::Result<Self> {
        let indices = LineFollowerRobotIndices::new(&instance_pre)?;
        Ok(Self { instance_pre, indices })
    }
    pub fn engine(&self) -> &wasmtime::Engine {
        self.instance_pre.engine()
    }
    pub fn instance_pre(&self) -> &wasmtime::component::InstancePre<_T> {
        &self.instance_pre
    }
    /// Instantiates a new instance of [`LineFollowerRobot`] within the
    /// `store` provided.
    ///
    /// This function will use `self` as the pre-instantiated
    /// instance to perform instantiation. Afterwards the preloaded
    /// indices in `self` are used to lookup all exports on the
    /// resulting instance.
    pub fn instantiate(
        &self,
        mut store: impl wasmtime::AsContextMut<Data = _T>,
    ) -> wasmtime::Result<LineFollowerRobot> {
        let mut store = store.as_context_mut();
        let instance = self.instance_pre.instantiate(&mut store)?;
        self.indices.load(&mut store, &instance)
    }
}
impl<_T: Send + 'static> LineFollowerRobotPre<_T> {
    /// Same as [`Self::instantiate`], except with `async`.
    pub async fn instantiate_async(
        &self,
        mut store: impl wasmtime::AsContextMut<Data = _T>,
    ) -> wasmtime::Result<LineFollowerRobot> {
        let mut store = store.as_context_mut();
        let instance = self.instance_pre.instantiate_async(&mut store).await?;
        self.indices.load(&mut store, &instance)
    }
}
/// Auto-generated bindings for index of the exports of
/// `line-follower-robot`.
///
/// This is an implementation detail of [`LineFollowerRobotPre`] and can
/// be constructed if needed as well.
///
/// For more information see [`LineFollowerRobot`] as well.
pub struct LineFollowerRobotIndices {
    interface0: exports::robot::GuestIndices,
}
#[automatically_derived]
impl ::core::clone::Clone for LineFollowerRobotIndices {
    #[inline]
    fn clone(&self) -> LineFollowerRobotIndices {
        LineFollowerRobotIndices {
            interface0: ::core::clone::Clone::clone(&self.interface0),
        }
    }
}
/// Auto-generated bindings for an instance a component which
/// implements the world `line-follower-robot`.
///
/// This structure can be created through a number of means
/// depending on your requirements and what you have on hand:
///
/// * The most convenient way is to use
///   [`LineFollowerRobot::instantiate`] which only needs a
///   [`Store`], [`Component`], and [`Linker`].
///
/// * Alternatively you can create a [`LineFollowerRobotPre`] ahead of
///   time with a [`Component`] to front-load string lookups
///   of exports once instead of per-instantiation. This
///   method then uses [`LineFollowerRobotPre::instantiate`] to
///   create a [`LineFollowerRobot`].
///
/// * If you've instantiated the instance yourself already
///   then you can use [`LineFollowerRobot::new`].
///
/// These methods are all equivalent to one another and move
/// around the tradeoff of what work is performed when.
///
/// [`Store`]: wasmtime::Store
/// [`Component`]: wasmtime::component::Component
/// [`Linker`]: wasmtime::component::Linker
pub struct LineFollowerRobot {
    interface0: exports::robot::Guest,
}
const _: () = {
    #[allow(unused_imports)]
    use wasmtime::component::__internal::anyhow;
    impl LineFollowerRobotIndices {
        /// Creates a new copy of `LineFollowerRobotIndices` bindings which can then
        /// be used to instantiate into a particular store.
        ///
        /// This method may fail if the component does not have the
        /// required exports.
        pub fn new<_T>(
            _instance_pre: &wasmtime::component::InstancePre<_T>,
        ) -> wasmtime::Result<Self> {
            let _component = _instance_pre.component();
            let _instance_type = _instance_pre.instance_type();
            let interface0 = exports::robot::GuestIndices::new(_instance_pre)?;
            Ok(LineFollowerRobotIndices {
                interface0,
            })
        }
        /// Uses the indices stored in `self` to load an instance
        /// of [`LineFollowerRobot`] from the instance provided.
        ///
        /// Note that at this time this method will additionally
        /// perform type-checks of all exports.
        pub fn load(
            &self,
            mut store: impl wasmtime::AsContextMut,
            instance: &wasmtime::component::Instance,
        ) -> wasmtime::Result<LineFollowerRobot> {
            let _ = &mut store;
            let _instance = instance;
            let interface0 = self.interface0.load(&mut store, &_instance)?;
            Ok(LineFollowerRobot { interface0 })
        }
    }
    impl LineFollowerRobot {
        /// Convenience wrapper around [`LineFollowerRobotPre::new`] and
        /// [`LineFollowerRobotPre::instantiate`].
        pub fn instantiate<_T>(
            store: impl wasmtime::AsContextMut<Data = _T>,
            component: &wasmtime::component::Component,
            linker: &wasmtime::component::Linker<_T>,
        ) -> wasmtime::Result<LineFollowerRobot> {
            let pre = linker.instantiate_pre(component)?;
            LineFollowerRobotPre::new(pre)?.instantiate(store)
        }
        /// Convenience wrapper around [`LineFollowerRobotIndices::new`] and
        /// [`LineFollowerRobotIndices::load`].
        pub fn new(
            mut store: impl wasmtime::AsContextMut,
            instance: &wasmtime::component::Instance,
        ) -> wasmtime::Result<LineFollowerRobot> {
            let indices = LineFollowerRobotIndices::new(&instance.instance_pre(&store))?;
            indices.load(&mut store, instance)
        }
        /// Convenience wrapper around [`LineFollowerRobotPre::new`] and
        /// [`LineFollowerRobotPre::instantiate_async`].
        pub async fn instantiate_async<_T>(
            store: impl wasmtime::AsContextMut<Data = _T>,
            component: &wasmtime::component::Component,
            linker: &wasmtime::component::Linker<_T>,
        ) -> wasmtime::Result<LineFollowerRobot>
        where
            _T: Send,
        {
            let pre = linker.instantiate_pre(component)?;
            LineFollowerRobotPre::new(pre)?.instantiate_async(store).await
        }
        pub fn add_to_linker<T, D>(
            linker: &mut wasmtime::component::Linker<T>,
            host_getter: fn(&mut T) -> D::Data<'_>,
        ) -> wasmtime::Result<()>
        where
            D: sensors::HostWithStore + motors::HostWithStore,
            for<'a> D::Data<'a>: sensors::Host + motors::Host,
            T: 'static,
        {
            sensors::add_to_linker::<T, D>(linker, host_getter)?;
            motors::add_to_linker::<T, D>(linker, host_getter)?;
            Ok(())
        }
        pub fn robot(&self) -> &exports::robot::Guest {
            &self.interface0
        }
    }
};
#[allow(clippy::all)]
pub mod sensors {
    #[allow(unused_imports)]
    use wasmtime::component::__internal::{anyhow, Box};
    #[component(enum)]
    #[repr(u8)]
    pub enum ReadError {
        #[component(name = "index-out-of-range")]
        IndexOutOfRange,
        #[component(name = "invalid-handle-type")]
        InvalidHandleType,
        #[component(name = "invalid-handle")]
        InvalidHandle,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ReadError {
        #[inline]
        fn clone(&self) -> ReadError {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ReadError {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ReadError {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ReadError {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ReadError {
        #[inline]
        fn eq(&self, other: &ReadError) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    unsafe impl wasmtime::component::Lower for ReadError {
        #[inline]
        fn linear_lower_to_flat<T>(
            &self,
            cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
            ty: wasmtime::component::__internal::InterfaceType,
            dst: &mut core::mem::MaybeUninit<Self::Lower>,
        ) -> wasmtime::component::__internal::anyhow::Result<()> {
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Enum(i) => &cx.types[i],
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            {
                #[allow(unused_unsafe, reason = "macro-generated code")]
                {
                    unsafe {
                        use ::wasmtime::MaybeUninitExt;
                        let m: &mut core::mem::MaybeUninit<_> = dst;
                        m.map(|p| &raw mut (*p).tag)
                    }
                }
            }
                .write(wasmtime::ValRaw::u32(*self as u32));
            Ok(())
        }
        #[inline]
        fn linear_lower_to_memory<T>(
            &self,
            cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
            ty: wasmtime::component::__internal::InterfaceType,
            mut offset: usize,
        ) -> wasmtime::component::__internal::anyhow::Result<()> {
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Enum(i) => &cx.types[i],
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            if true {
                if !(offset
                    % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize)
                    == 0)
                {
                    ::core::panicking::panic(
                        "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                    )
                }
            }
            let discrim = *self as u8;
            *cx.get::<1>(offset) = discrim.to_le_bytes();
            Ok(())
        }
    }
    unsafe impl wasmtime::component::Lift for ReadError {
        #[inline]
        fn linear_lift_from_flat(
            cx: &mut wasmtime::component::__internal::LiftContext<'_>,
            ty: wasmtime::component::__internal::InterfaceType,
            src: &Self::Lower,
        ) -> wasmtime::component::__internal::anyhow::Result<Self> {
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Enum(i) => &cx.types[i],
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            let discrim = src.tag.get_u32();
            if discrim >= 3 {
                return ::anyhow::__private::Err({
                    let error = ::anyhow::__private::format_err(
                        format_args!("unexpected discriminant: {0}", discrim),
                    );
                    error
                });
            }
            Ok(unsafe {
                wasmtime::component::__internal::transmute::<
                    u8,
                    ReadError,
                >(discrim as u8)
            })
        }
        #[inline]
        fn linear_lift_from_memory(
            cx: &mut wasmtime::component::__internal::LiftContext<'_>,
            ty: wasmtime::component::__internal::InterfaceType,
            bytes: &[u8],
        ) -> wasmtime::component::__internal::anyhow::Result<Self> {
            let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
            if true {
                if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                    ::core::panicking::panic(
                        "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                    )
                }
            }
            let discrim = bytes[0];
            if discrim >= 3 {
                return ::anyhow::__private::Err({
                    let error = ::anyhow::__private::format_err(
                        format_args!("unexpected discriminant: {0}", discrim),
                    );
                    error
                });
            }
            Ok(unsafe {
                wasmtime::component::__internal::transmute::<u8, ReadError>(discrim)
            })
        }
    }
    const _: () = {
        #[doc(hidden)]
        #[repr(C)]
        pub struct LowerReadError {
            tag: wasmtime::ValRaw,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for LowerReadError {
            #[inline]
            fn clone(&self) -> LowerReadError {
                let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for LowerReadError {}
        unsafe impl wasmtime::component::ComponentType for ReadError {
            type Lower = LowerReadError;
            #[inline]
            fn typecheck(
                ty: &wasmtime::component::__internal::InterfaceType,
                types: &wasmtime::component::__internal::InstanceType<'_>,
            ) -> wasmtime::component::__internal::anyhow::Result<()> {
                wasmtime::component::__internal::typecheck_enum(
                    ty,
                    types,
                    &["index-out-of-range", "invalid-handle-type", "invalid-handle"],
                )
            }
            const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::enum_(
                3usize,
            );
        }
        unsafe impl wasmtime::component::__internal::ComponentVariant for ReadError {
            const CASES: &'static [Option<
                wasmtime::component::__internal::CanonicalAbiInfo,
            >] = &[None, None, None];
        }
    };
    impl ReadError {
        pub fn name(&self) -> &'static str {
            match self {
                ReadError::IndexOutOfRange => "index-out-of-range",
                ReadError::InvalidHandleType => "invalid-handle-type",
                ReadError::InvalidHandle => "invalid-handle",
            }
        }
        pub fn message(&self) -> &'static str {
            match self {
                ReadError::IndexOutOfRange => "",
                ReadError::InvalidHandleType => "",
                ReadError::InvalidHandle => "",
            }
        }
    }
    impl core::fmt::Debug for ReadError {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.debug_struct("ReadError")
                .field("code", &(*self as i32))
                .field("name", &self.name())
                .field("message", &self.message())
                .finish()
        }
    }
    impl core::fmt::Display for ReadError {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.write_fmt(format_args!("{0} (error {1})", self.name(), *self as i32))
        }
    }
    impl core::error::Error for ReadError {}
    const _: () = {
        if !(1 == <ReadError as wasmtime::component::ComponentType>::SIZE32) {
            ::core::panicking::panic(
                "assertion failed: 1 == <ReadError as wasmtime::component::ComponentType>::SIZE32",
            )
        }
        if !(1 == <ReadError as wasmtime::component::ComponentType>::ALIGN32) {
            ::core::panicking::panic(
                "assertion failed: 1 == <ReadError as wasmtime::component::ComponentType>::ALIGN32",
            )
        }
    };
    pub type TimeUs = u32;
    const _: () = {
        if !(4 == <TimeUs as wasmtime::component::ComponentType>::SIZE32) {
            ::core::panicking::panic(
                "assertion failed: 4 == <TimeUs as wasmtime::component::ComponentType>::SIZE32",
            )
        }
        if !(4 == <TimeUs as wasmtime::component::ComponentType>::ALIGN32) {
            ::core::panicking::panic(
                "assertion failed: 4 == <TimeUs as wasmtime::component::ComponentType>::ALIGN32",
            )
        }
    };
    #[component(enum)]
    #[repr(u8)]
    pub enum SensorKind {
        #[component(name = "line")]
        Line,
        #[component(name = "imu")]
        Imu,
        #[component(name = "angle")]
        Angle,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SensorKind {
        #[inline]
        fn clone(&self) -> SensorKind {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for SensorKind {}
    #[automatically_derived]
    impl ::core::cmp::Eq for SensorKind {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SensorKind {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SensorKind {
        #[inline]
        fn eq(&self, other: &SensorKind) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    unsafe impl wasmtime::component::Lower for SensorKind {
        #[inline]
        fn linear_lower_to_flat<T>(
            &self,
            cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
            ty: wasmtime::component::__internal::InterfaceType,
            dst: &mut core::mem::MaybeUninit<Self::Lower>,
        ) -> wasmtime::component::__internal::anyhow::Result<()> {
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Enum(i) => &cx.types[i],
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            {
                #[allow(unused_unsafe, reason = "macro-generated code")]
                {
                    unsafe {
                        use ::wasmtime::MaybeUninitExt;
                        let m: &mut core::mem::MaybeUninit<_> = dst;
                        m.map(|p| &raw mut (*p).tag)
                    }
                }
            }
                .write(wasmtime::ValRaw::u32(*self as u32));
            Ok(())
        }
        #[inline]
        fn linear_lower_to_memory<T>(
            &self,
            cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
            ty: wasmtime::component::__internal::InterfaceType,
            mut offset: usize,
        ) -> wasmtime::component::__internal::anyhow::Result<()> {
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Enum(i) => &cx.types[i],
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            if true {
                if !(offset
                    % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize)
                    == 0)
                {
                    ::core::panicking::panic(
                        "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                    )
                }
            }
            let discrim = *self as u8;
            *cx.get::<1>(offset) = discrim.to_le_bytes();
            Ok(())
        }
    }
    unsafe impl wasmtime::component::Lift for SensorKind {
        #[inline]
        fn linear_lift_from_flat(
            cx: &mut wasmtime::component::__internal::LiftContext<'_>,
            ty: wasmtime::component::__internal::InterfaceType,
            src: &Self::Lower,
        ) -> wasmtime::component::__internal::anyhow::Result<Self> {
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Enum(i) => &cx.types[i],
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            let discrim = src.tag.get_u32();
            if discrim >= 3 {
                return ::anyhow::__private::Err({
                    let error = ::anyhow::__private::format_err(
                        format_args!("unexpected discriminant: {0}", discrim),
                    );
                    error
                });
            }
            Ok(unsafe {
                wasmtime::component::__internal::transmute::<
                    u8,
                    SensorKind,
                >(discrim as u8)
            })
        }
        #[inline]
        fn linear_lift_from_memory(
            cx: &mut wasmtime::component::__internal::LiftContext<'_>,
            ty: wasmtime::component::__internal::InterfaceType,
            bytes: &[u8],
        ) -> wasmtime::component::__internal::anyhow::Result<Self> {
            let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
            if true {
                if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                    ::core::panicking::panic(
                        "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                    )
                }
            }
            let discrim = bytes[0];
            if discrim >= 3 {
                return ::anyhow::__private::Err({
                    let error = ::anyhow::__private::format_err(
                        format_args!("unexpected discriminant: {0}", discrim),
                    );
                    error
                });
            }
            Ok(unsafe {
                wasmtime::component::__internal::transmute::<u8, SensorKind>(discrim)
            })
        }
    }
    const _: () = {
        #[doc(hidden)]
        #[repr(C)]
        pub struct LowerSensorKind {
            tag: wasmtime::ValRaw,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for LowerSensorKind {
            #[inline]
            fn clone(&self) -> LowerSensorKind {
                let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for LowerSensorKind {}
        unsafe impl wasmtime::component::ComponentType for SensorKind {
            type Lower = LowerSensorKind;
            #[inline]
            fn typecheck(
                ty: &wasmtime::component::__internal::InterfaceType,
                types: &wasmtime::component::__internal::InstanceType<'_>,
            ) -> wasmtime::component::__internal::anyhow::Result<()> {
                wasmtime::component::__internal::typecheck_enum(
                    ty,
                    types,
                    &["line", "imu", "angle"],
                )
            }
            const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::enum_(
                3usize,
            );
        }
        unsafe impl wasmtime::component::__internal::ComponentVariant for SensorKind {
            const CASES: &'static [Option<
                wasmtime::component::__internal::CanonicalAbiInfo,
            >] = &[None, None, None];
        }
    };
    impl core::fmt::Debug for SensorKind {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            match self {
                SensorKind::Line => f.debug_tuple("SensorKind::Line").finish(),
                SensorKind::Imu => f.debug_tuple("SensorKind::Imu").finish(),
                SensorKind::Angle => f.debug_tuple("SensorKind::Angle").finish(),
            }
        }
    }
    const _: () = {
        if !(1 == <SensorKind as wasmtime::component::ComponentType>::SIZE32) {
            ::core::panicking::panic(
                "assertion failed: 1 == <SensorKind as wasmtime::component::ComponentType>::SIZE32",
            )
        }
        if !(1 == <SensorKind as wasmtime::component::ComponentType>::ALIGN32) {
            ::core::panicking::panic(
                "assertion failed: 1 == <SensorKind as wasmtime::component::ComponentType>::ALIGN32",
            )
        }
    };
    #[component(record)]
    pub struct SensorIndexRange {
        #[component(name = "start")]
        pub start: u8,
        #[component(name = "count")]
        pub count: u8,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SensorIndexRange {
        #[inline]
        fn clone(&self) -> SensorIndexRange {
            let _: ::core::clone::AssertParamIsClone<u8>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for SensorIndexRange {}
    unsafe impl wasmtime::component::Lower for SensorIndexRange {
        #[inline]
        fn linear_lower_to_flat<T>(
            &self,
            cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
            ty: wasmtime::component::__internal::InterfaceType,
            dst: &mut core::mem::MaybeUninit<Self::Lower>,
        ) -> wasmtime::component::__internal::anyhow::Result<()> {
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Record(i) => &cx.types[i],
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            wasmtime::component::Lower::linear_lower_to_flat(
                &self.start,
                cx,
                ty.fields[0usize].ty,
                {
                    #[allow(unused_unsafe, reason = "macro-generated code")]
                    {
                        unsafe {
                            use ::wasmtime::MaybeUninitExt;
                            let m: &mut core::mem::MaybeUninit<_> = dst;
                            m.map(|p| &raw mut (*p).start)
                        }
                    }
                },
            )?;
            wasmtime::component::Lower::linear_lower_to_flat(
                &self.count,
                cx,
                ty.fields[1usize].ty,
                {
                    #[allow(unused_unsafe, reason = "macro-generated code")]
                    {
                        unsafe {
                            use ::wasmtime::MaybeUninitExt;
                            let m: &mut core::mem::MaybeUninit<_> = dst;
                            m.map(|p| &raw mut (*p).count)
                        }
                    }
                },
            )?;
            Ok(())
        }
        #[inline]
        fn linear_lower_to_memory<T>(
            &self,
            cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
            ty: wasmtime::component::__internal::InterfaceType,
            mut offset: usize,
        ) -> wasmtime::component::__internal::anyhow::Result<()> {
            if true {
                if !(offset
                    % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize)
                    == 0)
                {
                    ::core::panicking::panic(
                        "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                    )
                }
            }
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Record(i) => &cx.types[i],
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            wasmtime::component::Lower::linear_lower_to_memory(
                &self.start,
                cx,
                ty.fields[0usize].ty,
                <u8 as wasmtime::component::ComponentType>::ABI
                    .next_field32_size(&mut offset),
            )?;
            wasmtime::component::Lower::linear_lower_to_memory(
                &self.count,
                cx,
                ty.fields[1usize].ty,
                <u8 as wasmtime::component::ComponentType>::ABI
                    .next_field32_size(&mut offset),
            )?;
            Ok(())
        }
    }
    unsafe impl wasmtime::component::Lift for SensorIndexRange {
        #[inline]
        fn linear_lift_from_flat(
            cx: &mut wasmtime::component::__internal::LiftContext<'_>,
            ty: wasmtime::component::__internal::InterfaceType,
            src: &Self::Lower,
        ) -> wasmtime::component::__internal::anyhow::Result<Self> {
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Record(i) => &cx.types[i],
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            Ok(Self {
                start: <u8 as wasmtime::component::Lift>::linear_lift_from_flat(
                    cx,
                    ty.fields[0usize].ty,
                    &src.start,
                )?,
                count: <u8 as wasmtime::component::Lift>::linear_lift_from_flat(
                    cx,
                    ty.fields[1usize].ty,
                    &src.count,
                )?,
            })
        }
        #[inline]
        fn linear_lift_from_memory(
            cx: &mut wasmtime::component::__internal::LiftContext<'_>,
            ty: wasmtime::component::__internal::InterfaceType,
            bytes: &[u8],
        ) -> wasmtime::component::__internal::anyhow::Result<Self> {
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Record(i) => &cx.types[i],
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            if true {
                if !((bytes.as_ptr() as usize)
                    % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize)
                    == 0)
                {
                    ::core::panicking::panic(
                        "assertion failed: (bytes.as_ptr() as usize) %\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                    )
                }
            }
            let mut offset = 0;
            Ok(Self {
                start: <u8 as wasmtime::component::Lift>::linear_lift_from_memory(
                    cx,
                    ty.fields[0usize].ty,
                    &bytes[<u8 as wasmtime::component::ComponentType>::ABI
                        .next_field32_size(
                            &mut offset,
                        )..][..<u8 as wasmtime::component::ComponentType>::SIZE32],
                )?,
                count: <u8 as wasmtime::component::Lift>::linear_lift_from_memory(
                    cx,
                    ty.fields[1usize].ty,
                    &bytes[<u8 as wasmtime::component::ComponentType>::ABI
                        .next_field32_size(
                            &mut offset,
                        )..][..<u8 as wasmtime::component::ComponentType>::SIZE32],
                )?,
            })
        }
    }
    const _: () = {
        #[doc(hidden)]
        #[repr(C)]
        pub struct LowerSensorIndexRange<T0: Copy, T1: Copy> {
            start: T0,
            count: T1,
            _align: [wasmtime::ValRaw; 0],
        }
        #[automatically_derived]
        impl<
            T0: ::core::clone::Clone + Copy,
            T1: ::core::clone::Clone + Copy,
        > ::core::clone::Clone for LowerSensorIndexRange<T0, T1> {
            #[inline]
            fn clone(&self) -> LowerSensorIndexRange<T0, T1> {
                LowerSensorIndexRange {
                    start: ::core::clone::Clone::clone(&self.start),
                    count: ::core::clone::Clone::clone(&self.count),
                    _align: ::core::clone::Clone::clone(&self._align),
                }
            }
        }
        #[automatically_derived]
        impl<
            T0: ::core::marker::Copy + Copy,
            T1: ::core::marker::Copy + Copy,
        > ::core::marker::Copy for LowerSensorIndexRange<T0, T1> {}
        unsafe impl wasmtime::component::ComponentType for SensorIndexRange {
            type Lower = LowerSensorIndexRange<
                <u8 as wasmtime::component::ComponentType>::Lower,
                <u8 as wasmtime::component::ComponentType>::Lower,
            >;
            const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                &[
                    <u8 as wasmtime::component::ComponentType>::ABI,
                    <u8 as wasmtime::component::ComponentType>::ABI,
                ],
            );
            #[inline]
            fn typecheck(
                ty: &wasmtime::component::__internal::InterfaceType,
                types: &wasmtime::component::__internal::InstanceType<'_>,
            ) -> wasmtime::component::__internal::anyhow::Result<()> {
                wasmtime::component::__internal::typecheck_record(
                    ty,
                    types,
                    &[
                        ("start", <u8 as wasmtime::component::ComponentType>::typecheck),
                        ("count", <u8 as wasmtime::component::ComponentType>::typecheck),
                    ],
                )
            }
        }
    };
    impl core::fmt::Debug for SensorIndexRange {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.debug_struct("SensorIndexRange")
                .field("start", &self.start)
                .field("count", &self.count)
                .finish()
        }
    }
    const _: () = {
        if !(2 == <SensorIndexRange as wasmtime::component::ComponentType>::SIZE32) {
            ::core::panicking::panic(
                "assertion failed: 2 == <SensorIndexRange as wasmtime::component::ComponentType>::SIZE32",
            )
        }
        if !(1 == <SensorIndexRange as wasmtime::component::ComponentType>::ALIGN32) {
            ::core::panicking::panic(
                "assertion failed: 1 == <SensorIndexRange as wasmtime::component::ComponentType>::ALIGN32",
            )
        }
    };
    pub type SensorValue = i16;
    const _: () = {
        if !(2 == <SensorValue as wasmtime::component::ComponentType>::SIZE32) {
            ::core::panicking::panic(
                "assertion failed: 2 == <SensorValue as wasmtime::component::ComponentType>::SIZE32",
            )
        }
        if !(2 == <SensorValue as wasmtime::component::ComponentType>::ALIGN32) {
            ::core::panicking::panic(
                "assertion failed: 2 == <SensorValue as wasmtime::component::ComponentType>::ALIGN32",
            )
        }
    };
    pub type SensorValues = wasmtime::component::__internal::Vec<SensorValue>;
    const _: () = {
        if !(8 == <SensorValues as wasmtime::component::ComponentType>::SIZE32) {
            ::core::panicking::panic(
                "assertion failed: 8 == <SensorValues as wasmtime::component::ComponentType>::SIZE32",
            )
        }
        if !(4 == <SensorValues as wasmtime::component::ComponentType>::ALIGN32) {
            ::core::panicking::panic(
                "assertion failed: 4 == <SensorValues as wasmtime::component::ComponentType>::ALIGN32",
            )
        }
    };
    pub type FutureHandle = u32;
    const _: () = {
        if !(4 == <FutureHandle as wasmtime::component::ComponentType>::SIZE32) {
            ::core::panicking::panic(
                "assertion failed: 4 == <FutureHandle as wasmtime::component::ComponentType>::SIZE32",
            )
        }
        if !(4 == <FutureHandle as wasmtime::component::ComponentType>::ALIGN32) {
            ::core::panicking::panic(
                "assertion failed: 4 == <FutureHandle as wasmtime::component::ComponentType>::ALIGN32",
            )
        }
    };
    #[component(variant)]
    pub enum AsyncVoidResult {
        #[component(name = "blocked")]
        Blocked,
        #[component(name = "ready")]
        Ready,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AsyncVoidResult {
        #[inline]
        fn clone(&self) -> AsyncVoidResult {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for AsyncVoidResult {}
    unsafe impl wasmtime::component::Lower for AsyncVoidResult {
        #[inline]
        fn linear_lower_to_flat<T>(
            &self,
            cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
            ty: wasmtime::component::__internal::InterfaceType,
            dst: &mut core::mem::MaybeUninit<Self::Lower>,
        ) -> wasmtime::component::__internal::anyhow::Result<()> {
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Variant(i) => {
                    &cx.types[i]
                }
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            match self {
                Self::Blocked => {
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).tag)
                            }
                        }
                    }
                        .write(wasmtime::ValRaw::u32(0u32));
                    unsafe {
                        wasmtime::component::__internal::lower_payload(
                            {
                                #[allow(unused_unsafe, reason = "macro-generated code")]
                                {
                                    unsafe {
                                        use ::wasmtime::MaybeUninitExt;
                                        let m: &mut core::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).payload)
                                    }
                                }
                            },
                            |payload| {
                                #[allow(unused_unsafe, reason = "macro-generated code")]
                                {
                                    unsafe {
                                        use ::wasmtime::MaybeUninitExt;
                                        let m: &mut core::mem::MaybeUninit<_> = payload;
                                        m.map(|p| &raw mut (*p).Blocked)
                                    }
                                }
                            },
                            |dst| Ok(()),
                        )
                    }
                }
                Self::Ready => {
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).tag)
                            }
                        }
                    }
                        .write(wasmtime::ValRaw::u32(1u32));
                    unsafe {
                        wasmtime::component::__internal::lower_payload(
                            {
                                #[allow(unused_unsafe, reason = "macro-generated code")]
                                {
                                    unsafe {
                                        use ::wasmtime::MaybeUninitExt;
                                        let m: &mut core::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).payload)
                                    }
                                }
                            },
                            |payload| {
                                #[allow(unused_unsafe, reason = "macro-generated code")]
                                {
                                    unsafe {
                                        use ::wasmtime::MaybeUninitExt;
                                        let m: &mut core::mem::MaybeUninit<_> = payload;
                                        m.map(|p| &raw mut (*p).Ready)
                                    }
                                }
                            },
                            |dst| Ok(()),
                        )
                    }
                }
            }
        }
        #[inline]
        fn linear_lower_to_memory<T>(
            &self,
            cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
            ty: wasmtime::component::__internal::InterfaceType,
            mut offset: usize,
        ) -> wasmtime::component::__internal::anyhow::Result<()> {
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Variant(i) => {
                    &cx.types[i]
                }
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            if true {
                if !(offset
                    % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize)
                    == 0)
                {
                    ::core::panicking::panic(
                        "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                    )
                }
            }
            match self {
                Self::Blocked => {
                    *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                    Ok(())
                }
                Self::Ready => {
                    *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                    Ok(())
                }
            }
        }
    }
    unsafe impl wasmtime::component::Lift for AsyncVoidResult {
        #[inline]
        fn linear_lift_from_flat(
            cx: &mut wasmtime::component::__internal::LiftContext<'_>,
            ty: wasmtime::component::__internal::InterfaceType,
            src: &Self::Lower,
        ) -> wasmtime::component::__internal::anyhow::Result<Self> {
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Variant(i) => {
                    &cx.types[i]
                }
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            Ok(
                match src.tag.get_u32() {
                    0u32 => Self::Blocked,
                    1u32 => Self::Ready,
                    discrim => {
                        return ::anyhow::__private::Err(
                            ::anyhow::Error::msg(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("unexpected discriminant: {0}", discrim),
                                    )
                                }),
                            ),
                        );
                    }
                },
            )
        }
        #[inline]
        fn linear_lift_from_memory(
            cx: &mut wasmtime::component::__internal::LiftContext<'_>,
            ty: wasmtime::component::__internal::InterfaceType,
            bytes: &[u8],
        ) -> wasmtime::component::__internal::anyhow::Result<Self> {
            let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
            if true {
                if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                    ::core::panicking::panic(
                        "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                    )
                }
            }
            let discrim = bytes[0];
            let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
            let payload = &bytes[payload_offset..];
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Variant(i) => {
                    &cx.types[i]
                }
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            Ok(
                match discrim {
                    0u8 => Self::Blocked,
                    1u8 => Self::Ready,
                    discrim => {
                        return ::anyhow::__private::Err(
                            ::anyhow::Error::msg(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("unexpected discriminant: {0}", discrim),
                                    )
                                }),
                            ),
                        );
                    }
                },
            )
        }
    }
    const _: () = {
        #[doc(hidden)]
        #[repr(C)]
        pub struct LowerAsyncVoidResult {
            tag: wasmtime::ValRaw,
            payload: LowerPayloadAsyncVoidResult,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for LowerAsyncVoidResult {
            #[inline]
            fn clone(&self) -> LowerAsyncVoidResult {
                let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                let _: ::core::clone::AssertParamIsClone<LowerPayloadAsyncVoidResult>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for LowerAsyncVoidResult {}
        #[doc(hidden)]
        #[allow(non_snake_case)]
        #[repr(C)]
        union LowerPayloadAsyncVoidResult {
            Blocked: [wasmtime::ValRaw; 0],
            Ready: [wasmtime::ValRaw; 0],
        }
        #[automatically_derived]
        #[allow(non_snake_case)]
        impl ::core::clone::Clone for LowerPayloadAsyncVoidResult {
            #[inline]
            fn clone(&self) -> LowerPayloadAsyncVoidResult {
                let _: ::core::clone::AssertParamIsCopy<Self>;
                *self
            }
        }
        #[automatically_derived]
        #[allow(non_snake_case)]
        impl ::core::marker::Copy for LowerPayloadAsyncVoidResult {}
        unsafe impl wasmtime::component::ComponentType for AsyncVoidResult {
            type Lower = LowerAsyncVoidResult;
            #[inline]
            fn typecheck(
                ty: &wasmtime::component::__internal::InterfaceType,
                types: &wasmtime::component::__internal::InstanceType<'_>,
            ) -> wasmtime::component::__internal::anyhow::Result<()> {
                wasmtime::component::__internal::typecheck_variant(
                    ty,
                    types,
                    &[("blocked", None), ("ready", None)],
                )
            }
            const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                &[None, None],
            );
        }
        unsafe impl wasmtime::component::__internal::ComponentVariant
        for AsyncVoidResult {
            const CASES: &'static [Option<
                wasmtime::component::__internal::CanonicalAbiInfo,
            >] = &[None, None];
        }
    };
    impl core::fmt::Debug for AsyncVoidResult {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            match self {
                AsyncVoidResult::Blocked => {
                    f.debug_tuple("AsyncVoidResult::Blocked").finish()
                }
                AsyncVoidResult::Ready => {
                    f.debug_tuple("AsyncVoidResult::Ready").finish()
                }
            }
        }
    }
    const _: () = {
        if !(1 == <AsyncVoidResult as wasmtime::component::ComponentType>::SIZE32) {
            ::core::panicking::panic(
                "assertion failed: 1 == <AsyncVoidResult as wasmtime::component::ComponentType>::SIZE32",
            )
        }
        if !(1 == <AsyncVoidResult as wasmtime::component::ComponentType>::ALIGN32) {
            ::core::panicking::panic(
                "assertion failed: 1 == <AsyncVoidResult as wasmtime::component::ComponentType>::ALIGN32",
            )
        }
    };
    #[component(variant)]
    pub enum AsyncSensorResult {
        #[component(name = "blocked")]
        Blocked,
        #[component(name = "ready")]
        Ready(SensorValues),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AsyncSensorResult {
        #[inline]
        fn clone(&self) -> AsyncSensorResult {
            match self {
                AsyncSensorResult::Blocked => AsyncSensorResult::Blocked,
                AsyncSensorResult::Ready(__self_0) => {
                    AsyncSensorResult::Ready(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    unsafe impl wasmtime::component::Lower for AsyncSensorResult {
        #[inline]
        fn linear_lower_to_flat<T>(
            &self,
            cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
            ty: wasmtime::component::__internal::InterfaceType,
            dst: &mut core::mem::MaybeUninit<Self::Lower>,
        ) -> wasmtime::component::__internal::anyhow::Result<()> {
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Variant(i) => {
                    &cx.types[i]
                }
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            match self {
                Self::Blocked => {
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).tag)
                            }
                        }
                    }
                        .write(wasmtime::ValRaw::u32(0u32));
                    unsafe {
                        wasmtime::component::__internal::lower_payload(
                            {
                                #[allow(unused_unsafe, reason = "macro-generated code")]
                                {
                                    unsafe {
                                        use ::wasmtime::MaybeUninitExt;
                                        let m: &mut core::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).payload)
                                    }
                                }
                            },
                            |payload| {
                                #[allow(unused_unsafe, reason = "macro-generated code")]
                                {
                                    unsafe {
                                        use ::wasmtime::MaybeUninitExt;
                                        let m: &mut core::mem::MaybeUninit<_> = payload;
                                        m.map(|p| &raw mut (*p).Blocked)
                                    }
                                }
                            },
                            |dst| Ok(()),
                        )
                    }
                }
                Self::Ready(value) => {
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).tag)
                            }
                        }
                    }
                        .write(wasmtime::ValRaw::u32(1u32));
                    unsafe {
                        wasmtime::component::__internal::lower_payload(
                            {
                                #[allow(unused_unsafe, reason = "macro-generated code")]
                                {
                                    unsafe {
                                        use ::wasmtime::MaybeUninitExt;
                                        let m: &mut core::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).payload)
                                    }
                                }
                            },
                            |payload| {
                                #[allow(unused_unsafe, reason = "macro-generated code")]
                                {
                                    unsafe {
                                        use ::wasmtime::MaybeUninitExt;
                                        let m: &mut core::mem::MaybeUninit<_> = payload;
                                        m.map(|p| &raw mut (*p).Ready)
                                    }
                                }
                            },
                            |dst| {
                                value
                                    .linear_lower_to_flat(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        dst,
                                    )
                            },
                        )
                    }
                }
            }
        }
        #[inline]
        fn linear_lower_to_memory<T>(
            &self,
            cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
            ty: wasmtime::component::__internal::InterfaceType,
            mut offset: usize,
        ) -> wasmtime::component::__internal::anyhow::Result<()> {
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Variant(i) => {
                    &cx.types[i]
                }
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            if true {
                if !(offset
                    % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize)
                    == 0)
                {
                    ::core::panicking::panic(
                        "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                    )
                }
            }
            match self {
                Self::Blocked => {
                    *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                    Ok(())
                }
                Self::Ready(value) => {
                    *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                    value
                        .linear_lower_to_memory(
                            cx,
                            ty
                                .cases[1usize]
                                .unwrap_or_else(
                                    wasmtime::component::__internal::bad_type_info,
                                ),
                            offset
                                + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                        )
                }
            }
        }
    }
    unsafe impl wasmtime::component::Lift for AsyncSensorResult {
        #[inline]
        fn linear_lift_from_flat(
            cx: &mut wasmtime::component::__internal::LiftContext<'_>,
            ty: wasmtime::component::__internal::InterfaceType,
            src: &Self::Lower,
        ) -> wasmtime::component::__internal::anyhow::Result<Self> {
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Variant(i) => {
                    &cx.types[i]
                }
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            Ok(
                match src.tag.get_u32() {
                    0u32 => Self::Blocked,
                    1u32 => {
                        Self::Ready(
                            <SensorValues as wasmtime::component::Lift>::linear_lift_from_flat(
                                cx,
                                ty
                                    .cases[1usize]
                                    .unwrap_or_else(
                                        wasmtime::component::__internal::bad_type_info,
                                    ),
                                unsafe { &src.payload.Ready },
                            )?,
                        )
                    }
                    discrim => {
                        return ::anyhow::__private::Err(
                            ::anyhow::Error::msg(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("unexpected discriminant: {0}", discrim),
                                    )
                                }),
                            ),
                        );
                    }
                },
            )
        }
        #[inline]
        fn linear_lift_from_memory(
            cx: &mut wasmtime::component::__internal::LiftContext<'_>,
            ty: wasmtime::component::__internal::InterfaceType,
            bytes: &[u8],
        ) -> wasmtime::component::__internal::anyhow::Result<Self> {
            let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
            if true {
                if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                    ::core::panicking::panic(
                        "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                    )
                }
            }
            let discrim = bytes[0];
            let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
            let payload = &bytes[payload_offset..];
            let ty = match ty {
                wasmtime::component::__internal::InterfaceType::Variant(i) => {
                    &cx.types[i]
                }
                _ => wasmtime::component::__internal::bad_type_info(),
            };
            Ok(
                match discrim {
                    0u8 => Self::Blocked,
                    1u8 => {
                        Self::Ready(
                            <SensorValues as wasmtime::component::Lift>::linear_lift_from_memory(
                                cx,
                                ty
                                    .cases[1usize]
                                    .unwrap_or_else(
                                        wasmtime::component::__internal::bad_type_info,
                                    ),
                                &payload[..<SensorValues as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                        )
                    }
                    discrim => {
                        return ::anyhow::__private::Err(
                            ::anyhow::Error::msg(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("unexpected discriminant: {0}", discrim),
                                    )
                                }),
                            ),
                        );
                    }
                },
            )
        }
    }
    const _: () = {
        #[doc(hidden)]
        #[repr(C)]
        pub struct LowerAsyncSensorResult<T1: Copy> {
            tag: wasmtime::ValRaw,
            payload: LowerPayloadAsyncSensorResult<T1>,
        }
        #[automatically_derived]
        impl<T1: ::core::clone::Clone + Copy> ::core::clone::Clone
        for LowerAsyncSensorResult<T1> {
            #[inline]
            fn clone(&self) -> LowerAsyncSensorResult<T1> {
                LowerAsyncSensorResult {
                    tag: ::core::clone::Clone::clone(&self.tag),
                    payload: ::core::clone::Clone::clone(&self.payload),
                }
            }
        }
        #[automatically_derived]
        impl<T1: ::core::marker::Copy + Copy> ::core::marker::Copy
        for LowerAsyncSensorResult<T1> {}
        #[doc(hidden)]
        #[allow(non_snake_case)]
        #[repr(C)]
        union LowerPayloadAsyncSensorResult<T1: Copy> {
            Blocked: [wasmtime::ValRaw; 0],
            Ready: T1,
        }
        #[automatically_derived]
        #[allow(non_snake_case)]
        impl<T1: ::core::marker::Copy + ::core::clone::Clone + Copy> ::core::clone::Clone
        for LowerPayloadAsyncSensorResult<T1> {
            #[inline]
            fn clone(&self) -> LowerPayloadAsyncSensorResult<T1> {
                let _: ::core::clone::AssertParamIsCopy<Self>;
                *self
            }
        }
        #[automatically_derived]
        #[allow(non_snake_case)]
        impl<T1: ::core::marker::Copy + Copy> ::core::marker::Copy
        for LowerPayloadAsyncSensorResult<T1> {}
        unsafe impl wasmtime::component::ComponentType for AsyncSensorResult {
            type Lower = LowerAsyncSensorResult<
                <SensorValues as wasmtime::component::ComponentType>::Lower,
            >;
            #[inline]
            fn typecheck(
                ty: &wasmtime::component::__internal::InterfaceType,
                types: &wasmtime::component::__internal::InstanceType<'_>,
            ) -> wasmtime::component::__internal::anyhow::Result<()> {
                wasmtime::component::__internal::typecheck_variant(
                    ty,
                    types,
                    &[
                        ("blocked", None),
                        (
                            "ready",
                            Some(
                                <SensorValues as wasmtime::component::ComponentType>::typecheck,
                            ),
                        ),
                    ],
                )
            }
            const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                &[None, Some(<SensorValues as wasmtime::component::ComponentType>::ABI)],
            );
        }
        unsafe impl wasmtime::component::__internal::ComponentVariant
        for AsyncSensorResult {
            const CASES: &'static [Option<
                wasmtime::component::__internal::CanonicalAbiInfo,
            >] = &[
                None,
                Some(<SensorValues as wasmtime::component::ComponentType>::ABI),
            ];
        }
    };
    impl core::fmt::Debug for AsyncSensorResult {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            match self {
                AsyncSensorResult::Blocked => {
                    f.debug_tuple("AsyncSensorResult::Blocked").finish()
                }
                AsyncSensorResult::Ready(e) => {
                    f.debug_tuple("AsyncSensorResult::Ready").field(e).finish()
                }
            }
        }
    }
    const _: () = {
        if !(12 == <AsyncSensorResult as wasmtime::component::ComponentType>::SIZE32) {
            ::core::panicking::panic(
                "assertion failed: 12 == <AsyncSensorResult as wasmtime::component::ComponentType>::SIZE32",
            )
        }
        if !(4 == <AsyncSensorResult as wasmtime::component::ComponentType>::ALIGN32) {
            ::core::panicking::panic(
                "assertion failed: 4 == <AsyncSensorResult as wasmtime::component::ComponentType>::ALIGN32",
            )
        }
    };
    pub trait HostWithStore: wasmtime::component::HasData {}
    impl<_T: ?Sized> HostWithStore for _T
    where
        _T: wasmtime::component::HasData,
    {}
    pub trait Host {
        fn current_time(&mut self) -> TimeUs;
        fn sleep_blocking_for(&mut self, us: TimeUs) -> ();
        fn sleep_blocking_until(&mut self, us: TimeUs) -> ();
        fn read_sensor_blocking(
            &mut self,
            sensor: SensorKind,
            indexes: SensorIndexRange,
        ) -> Result<SensorValues, ReadError>;
        fn sleep_async_for(&mut self, us: TimeUs) -> FutureHandle;
        fn sleep_async_until(&mut self, us: TimeUs) -> FutureHandle;
        fn read_sensor_async(
            &mut self,
            sensor: SensorKind,
            sensor_index_range: SensorIndexRange,
        ) -> FutureHandle;
        fn poll_timer(
            &mut self,
            handle: FutureHandle,
        ) -> Result<AsyncVoidResult, ReadError>;
        fn poll_sensor(
            &mut self,
            handle: FutureHandle,
        ) -> Result<AsyncSensorResult, ReadError>;
        fn forget_handle(&mut self, handle: FutureHandle) -> ();
    }
    impl<_T: Host + ?Sized> Host for &mut _T {
        fn current_time(&mut self) -> TimeUs {
            Host::current_time(*self)
        }
        fn sleep_blocking_for(&mut self, us: TimeUs) -> () {
            Host::sleep_blocking_for(*self, us)
        }
        fn sleep_blocking_until(&mut self, us: TimeUs) -> () {
            Host::sleep_blocking_until(*self, us)
        }
        fn read_sensor_blocking(
            &mut self,
            sensor: SensorKind,
            indexes: SensorIndexRange,
        ) -> Result<SensorValues, ReadError> {
            Host::read_sensor_blocking(*self, sensor, indexes)
        }
        fn sleep_async_for(&mut self, us: TimeUs) -> FutureHandle {
            Host::sleep_async_for(*self, us)
        }
        fn sleep_async_until(&mut self, us: TimeUs) -> FutureHandle {
            Host::sleep_async_until(*self, us)
        }
        fn read_sensor_async(
            &mut self,
            sensor: SensorKind,
            sensor_index_range: SensorIndexRange,
        ) -> FutureHandle {
            Host::read_sensor_async(*self, sensor, sensor_index_range)
        }
        fn poll_timer(
            &mut self,
            handle: FutureHandle,
        ) -> Result<AsyncVoidResult, ReadError> {
            Host::poll_timer(*self, handle)
        }
        fn poll_sensor(
            &mut self,
            handle: FutureHandle,
        ) -> Result<AsyncSensorResult, ReadError> {
            Host::poll_sensor(*self, handle)
        }
        fn forget_handle(&mut self, handle: FutureHandle) -> () {
            Host::forget_handle(*self, handle)
        }
    }
    pub fn add_to_linker<T, D>(
        linker: &mut wasmtime::component::Linker<T>,
        host_getter: fn(&mut T) -> D::Data<'_>,
    ) -> wasmtime::Result<()>
    where
        D: HostWithStore,
        for<'a> D::Data<'a>: Host,
        T: 'static,
    {
        let mut inst = linker.instance("sensors")?;
        inst.func_wrap(
            "current-time",
            move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                let host = &mut host_getter(caller.data_mut());
                let r = Host::current_time(host);
                Ok((r,))
            },
        )?;
        inst.func_wrap(
            "sleep-blocking-for",
            move |mut caller: wasmtime::StoreContextMut<'_, T>, (arg0,): (TimeUs,)| {
                let host = &mut host_getter(caller.data_mut());
                let r = Host::sleep_blocking_for(host, arg0);
                Ok(r)
            },
        )?;
        inst.func_wrap(
            "sleep-blocking-until",
            move |mut caller: wasmtime::StoreContextMut<'_, T>, (arg0,): (TimeUs,)| {
                let host = &mut host_getter(caller.data_mut());
                let r = Host::sleep_blocking_until(host, arg0);
                Ok(r)
            },
        )?;
        inst.func_wrap(
            "read-sensor-blocking",
            move |
                mut caller: wasmtime::StoreContextMut<'_, T>,
                (arg0, arg1): (SensorKind, SensorIndexRange)|
            {
                let host = &mut host_getter(caller.data_mut());
                let r = Host::read_sensor_blocking(host, arg0, arg1);
                Ok((r,))
            },
        )?;
        inst.func_wrap(
            "sleep-async-for",
            move |mut caller: wasmtime::StoreContextMut<'_, T>, (arg0,): (TimeUs,)| {
                let host = &mut host_getter(caller.data_mut());
                let r = Host::sleep_async_for(host, arg0);
                Ok((r,))
            },
        )?;
        inst.func_wrap(
            "sleep-async-until",
            move |mut caller: wasmtime::StoreContextMut<'_, T>, (arg0,): (TimeUs,)| {
                let host = &mut host_getter(caller.data_mut());
                let r = Host::sleep_async_until(host, arg0);
                Ok((r,))
            },
        )?;
        inst.func_wrap(
            "read-sensor-async",
            move |
                mut caller: wasmtime::StoreContextMut<'_, T>,
                (arg0, arg1): (SensorKind, SensorIndexRange)|
            {
                let host = &mut host_getter(caller.data_mut());
                let r = Host::read_sensor_async(host, arg0, arg1);
                Ok((r,))
            },
        )?;
        inst.func_wrap(
            "poll-timer",
            move |
                mut caller: wasmtime::StoreContextMut<'_, T>,
                (arg0,): (FutureHandle,)|
            {
                let host = &mut host_getter(caller.data_mut());
                let r = Host::poll_timer(host, arg0);
                Ok((r,))
            },
        )?;
        inst.func_wrap(
            "poll-sensor",
            move |
                mut caller: wasmtime::StoreContextMut<'_, T>,
                (arg0,): (FutureHandle,)|
            {
                let host = &mut host_getter(caller.data_mut());
                let r = Host::poll_sensor(host, arg0);
                Ok((r,))
            },
        )?;
        inst.func_wrap(
            "forget-handle",
            move |
                mut caller: wasmtime::StoreContextMut<'_, T>,
                (arg0,): (FutureHandle,)|
            {
                let host = &mut host_getter(caller.data_mut());
                let r = Host::forget_handle(host, arg0);
                Ok(r)
            },
        )?;
        Ok(())
    }
}
#[allow(clippy::all)]
pub mod motors {
    #[allow(unused_imports)]
    use wasmtime::component::__internal::{anyhow, Box};
    pub type MotorPower = i16;
    const _: () = {
        if !(2 == <MotorPower as wasmtime::component::ComponentType>::SIZE32) {
            ::core::panicking::panic(
                "assertion failed: 2 == <MotorPower as wasmtime::component::ComponentType>::SIZE32",
            )
        }
        if !(2 == <MotorPower as wasmtime::component::ComponentType>::ALIGN32) {
            ::core::panicking::panic(
                "assertion failed: 2 == <MotorPower as wasmtime::component::ComponentType>::ALIGN32",
            )
        }
    };
    pub trait HostWithStore: wasmtime::component::HasData {}
    impl<_T: ?Sized> HostWithStore for _T
    where
        _T: wasmtime::component::HasData,
    {}
    pub trait Host {
        fn set_power(&mut self, left: MotorPower, right: MotorPower) -> ();
    }
    impl<_T: Host + ?Sized> Host for &mut _T {
        fn set_power(&mut self, left: MotorPower, right: MotorPower) -> () {
            Host::set_power(*self, left, right)
        }
    }
    pub fn add_to_linker<T, D>(
        linker: &mut wasmtime::component::Linker<T>,
        host_getter: fn(&mut T) -> D::Data<'_>,
    ) -> wasmtime::Result<()>
    where
        D: HostWithStore,
        for<'a> D::Data<'a>: Host,
        T: 'static,
    {
        let mut inst = linker.instance("motors")?;
        inst.func_wrap(
            "set-power",
            move |
                mut caller: wasmtime::StoreContextMut<'_, T>,
                (arg0, arg1): (MotorPower, MotorPower)|
            {
                let host = &mut host_getter(caller.data_mut());
                let r = Host::set_power(host, arg0, arg1);
                Ok(r)
            },
        )?;
        Ok(())
    }
}
pub mod exports {
    #[allow(clippy::all)]
    pub mod robot {
        #[allow(unused_imports)]
        use wasmtime::component::__internal::{anyhow, Box};
        #[component(record)]
        pub struct Color {
            #[component(name = "r")]
            pub r: u8,
            #[component(name = "g")]
            pub g: u8,
            #[component(name = "b")]
            pub b: u8,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Color {
            #[inline]
            fn clone(&self) -> Color {
                let _: ::core::clone::AssertParamIsClone<u8>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Color {}
        unsafe impl wasmtime::component::Lower for Color {
            #[inline]
            fn linear_lower_to_flat<T>(
                &self,
                cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                ty: wasmtime::component::__internal::InterfaceType,
                dst: &mut core::mem::MaybeUninit<Self::Lower>,
            ) -> wasmtime::component::__internal::anyhow::Result<()> {
                let ty = match ty {
                    wasmtime::component::__internal::InterfaceType::Record(i) => {
                        &cx.types[i]
                    }
                    _ => wasmtime::component::__internal::bad_type_info(),
                };
                wasmtime::component::Lower::linear_lower_to_flat(
                    &self.r,
                    cx,
                    ty.fields[0usize].ty,
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).r)
                            }
                        }
                    },
                )?;
                wasmtime::component::Lower::linear_lower_to_flat(
                    &self.g,
                    cx,
                    ty.fields[1usize].ty,
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).g)
                            }
                        }
                    },
                )?;
                wasmtime::component::Lower::linear_lower_to_flat(
                    &self.b,
                    cx,
                    ty.fields[2usize].ty,
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).b)
                            }
                        }
                    },
                )?;
                Ok(())
            }
            #[inline]
            fn linear_lower_to_memory<T>(
                &self,
                cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                ty: wasmtime::component::__internal::InterfaceType,
                mut offset: usize,
            ) -> wasmtime::component::__internal::anyhow::Result<()> {
                if true {
                    if !(offset
                        % (<Self as wasmtime::component::ComponentType>::ALIGN32
                            as usize) == 0)
                    {
                        ::core::panicking::panic(
                            "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                        )
                    }
                }
                let ty = match ty {
                    wasmtime::component::__internal::InterfaceType::Record(i) => {
                        &cx.types[i]
                    }
                    _ => wasmtime::component::__internal::bad_type_info(),
                };
                wasmtime::component::Lower::linear_lower_to_memory(
                    &self.r,
                    cx,
                    ty.fields[0usize].ty,
                    <u8 as wasmtime::component::ComponentType>::ABI
                        .next_field32_size(&mut offset),
                )?;
                wasmtime::component::Lower::linear_lower_to_memory(
                    &self.g,
                    cx,
                    ty.fields[1usize].ty,
                    <u8 as wasmtime::component::ComponentType>::ABI
                        .next_field32_size(&mut offset),
                )?;
                wasmtime::component::Lower::linear_lower_to_memory(
                    &self.b,
                    cx,
                    ty.fields[2usize].ty,
                    <u8 as wasmtime::component::ComponentType>::ABI
                        .next_field32_size(&mut offset),
                )?;
                Ok(())
            }
        }
        unsafe impl wasmtime::component::Lift for Color {
            #[inline]
            fn linear_lift_from_flat(
                cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                ty: wasmtime::component::__internal::InterfaceType,
                src: &Self::Lower,
            ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                let ty = match ty {
                    wasmtime::component::__internal::InterfaceType::Record(i) => {
                        &cx.types[i]
                    }
                    _ => wasmtime::component::__internal::bad_type_info(),
                };
                Ok(Self {
                    r: <u8 as wasmtime::component::Lift>::linear_lift_from_flat(
                        cx,
                        ty.fields[0usize].ty,
                        &src.r,
                    )?,
                    g: <u8 as wasmtime::component::Lift>::linear_lift_from_flat(
                        cx,
                        ty.fields[1usize].ty,
                        &src.g,
                    )?,
                    b: <u8 as wasmtime::component::Lift>::linear_lift_from_flat(
                        cx,
                        ty.fields[2usize].ty,
                        &src.b,
                    )?,
                })
            }
            #[inline]
            fn linear_lift_from_memory(
                cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                ty: wasmtime::component::__internal::InterfaceType,
                bytes: &[u8],
            ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                let ty = match ty {
                    wasmtime::component::__internal::InterfaceType::Record(i) => {
                        &cx.types[i]
                    }
                    _ => wasmtime::component::__internal::bad_type_info(),
                };
                if true {
                    if !((bytes.as_ptr() as usize)
                        % (<Self as wasmtime::component::ComponentType>::ALIGN32
                            as usize) == 0)
                    {
                        ::core::panicking::panic(
                            "assertion failed: (bytes.as_ptr() as usize) %\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                        )
                    }
                }
                let mut offset = 0;
                Ok(Self {
                    r: <u8 as wasmtime::component::Lift>::linear_lift_from_memory(
                        cx,
                        ty.fields[0usize].ty,
                        &bytes[<u8 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(
                                &mut offset,
                            )..][..<u8 as wasmtime::component::ComponentType>::SIZE32],
                    )?,
                    g: <u8 as wasmtime::component::Lift>::linear_lift_from_memory(
                        cx,
                        ty.fields[1usize].ty,
                        &bytes[<u8 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(
                                &mut offset,
                            )..][..<u8 as wasmtime::component::ComponentType>::SIZE32],
                    )?,
                    b: <u8 as wasmtime::component::Lift>::linear_lift_from_memory(
                        cx,
                        ty.fields[2usize].ty,
                        &bytes[<u8 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(
                                &mut offset,
                            )..][..<u8 as wasmtime::component::ComponentType>::SIZE32],
                    )?,
                })
            }
        }
        const _: () = {
            #[doc(hidden)]
            #[repr(C)]
            pub struct LowerColor<T0: Copy, T1: Copy, T2: Copy> {
                r: T0,
                g: T1,
                b: T2,
                _align: [wasmtime::ValRaw; 0],
            }
            #[automatically_derived]
            impl<
                T0: ::core::clone::Clone + Copy,
                T1: ::core::clone::Clone + Copy,
                T2: ::core::clone::Clone + Copy,
            > ::core::clone::Clone for LowerColor<T0, T1, T2> {
                #[inline]
                fn clone(&self) -> LowerColor<T0, T1, T2> {
                    LowerColor {
                        r: ::core::clone::Clone::clone(&self.r),
                        g: ::core::clone::Clone::clone(&self.g),
                        b: ::core::clone::Clone::clone(&self.b),
                        _align: ::core::clone::Clone::clone(&self._align),
                    }
                }
            }
            #[automatically_derived]
            impl<
                T0: ::core::marker::Copy + Copy,
                T1: ::core::marker::Copy + Copy,
                T2: ::core::marker::Copy + Copy,
            > ::core::marker::Copy for LowerColor<T0, T1, T2> {}
            unsafe impl wasmtime::component::ComponentType for Color {
                type Lower = LowerColor<
                    <u8 as wasmtime::component::ComponentType>::Lower,
                    <u8 as wasmtime::component::ComponentType>::Lower,
                    <u8 as wasmtime::component::ComponentType>::Lower,
                >;
                const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                    &[
                        <u8 as wasmtime::component::ComponentType>::ABI,
                        <u8 as wasmtime::component::ComponentType>::ABI,
                        <u8 as wasmtime::component::ComponentType>::ABI,
                    ],
                );
                #[inline]
                fn typecheck(
                    ty: &wasmtime::component::__internal::InterfaceType,
                    types: &wasmtime::component::__internal::InstanceType<'_>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    wasmtime::component::__internal::typecheck_record(
                        ty,
                        types,
                        &[
                            ("r", <u8 as wasmtime::component::ComponentType>::typecheck),
                            ("g", <u8 as wasmtime::component::ComponentType>::typecheck),
                            ("b", <u8 as wasmtime::component::ComponentType>::typecheck),
                        ],
                    )
                }
            }
        };
        impl core::fmt::Debug for Color {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                f.debug_struct("Color")
                    .field("r", &self.r)
                    .field("g", &self.g)
                    .field("b", &self.b)
                    .finish()
            }
        }
        const _: () = {
            if !(3 == <Color as wasmtime::component::ComponentType>::SIZE32) {
                ::core::panicking::panic(
                    "assertion failed: 3 == <Color as wasmtime::component::ComponentType>::SIZE32",
                )
            }
            if !(1 == <Color as wasmtime::component::ComponentType>::ALIGN32) {
                ::core::panicking::panic(
                    "assertion failed: 1 == <Color as wasmtime::component::ComponentType>::ALIGN32",
                )
            }
        };
        #[component(record)]
        pub struct Configuration {
            #[component(name = "name")]
            pub name: wasmtime::component::__internal::String,
            #[component(name = "color-main")]
            pub color_main: Color,
            #[component(name = "color-secondary")]
            pub color_secondary: Color,
            #[component(name = "width-axle")]
            pub width_axle: i32,
            #[component(name = "length-front")]
            pub length_front: i32,
            #[component(name = "length-back")]
            pub length_back: i32,
            #[component(name = "clearing-back")]
            pub clearing_back: i32,
            #[component(name = "wheel-radius")]
            pub wheel_radius: i32,
            #[component(name = "gear-ratio-num")]
            pub gear_ratio_num: i32,
            #[component(name = "gear-ratio-den")]
            pub gear_ratio_den: i32,
            #[component(name = "front-sensors-spacing")]
            pub front_sensors_spacing: i32,
            #[component(name = "front-sensors-height")]
            pub front_sensors_height: i32,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Configuration {
            #[inline]
            fn clone(&self) -> Configuration {
                Configuration {
                    name: ::core::clone::Clone::clone(&self.name),
                    color_main: ::core::clone::Clone::clone(&self.color_main),
                    color_secondary: ::core::clone::Clone::clone(&self.color_secondary),
                    width_axle: ::core::clone::Clone::clone(&self.width_axle),
                    length_front: ::core::clone::Clone::clone(&self.length_front),
                    length_back: ::core::clone::Clone::clone(&self.length_back),
                    clearing_back: ::core::clone::Clone::clone(&self.clearing_back),
                    wheel_radius: ::core::clone::Clone::clone(&self.wheel_radius),
                    gear_ratio_num: ::core::clone::Clone::clone(&self.gear_ratio_num),
                    gear_ratio_den: ::core::clone::Clone::clone(&self.gear_ratio_den),
                    front_sensors_spacing: ::core::clone::Clone::clone(
                        &self.front_sensors_spacing,
                    ),
                    front_sensors_height: ::core::clone::Clone::clone(
                        &self.front_sensors_height,
                    ),
                }
            }
        }
        unsafe impl wasmtime::component::Lower for Configuration {
            #[inline]
            fn linear_lower_to_flat<T>(
                &self,
                cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                ty: wasmtime::component::__internal::InterfaceType,
                dst: &mut core::mem::MaybeUninit<Self::Lower>,
            ) -> wasmtime::component::__internal::anyhow::Result<()> {
                let ty = match ty {
                    wasmtime::component::__internal::InterfaceType::Record(i) => {
                        &cx.types[i]
                    }
                    _ => wasmtime::component::__internal::bad_type_info(),
                };
                wasmtime::component::Lower::linear_lower_to_flat(
                    &self.name,
                    cx,
                    ty.fields[0usize].ty,
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).name)
                            }
                        }
                    },
                )?;
                wasmtime::component::Lower::linear_lower_to_flat(
                    &self.color_main,
                    cx,
                    ty.fields[1usize].ty,
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).color_main)
                            }
                        }
                    },
                )?;
                wasmtime::component::Lower::linear_lower_to_flat(
                    &self.color_secondary,
                    cx,
                    ty.fields[2usize].ty,
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).color_secondary)
                            }
                        }
                    },
                )?;
                wasmtime::component::Lower::linear_lower_to_flat(
                    &self.width_axle,
                    cx,
                    ty.fields[3usize].ty,
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).width_axle)
                            }
                        }
                    },
                )?;
                wasmtime::component::Lower::linear_lower_to_flat(
                    &self.length_front,
                    cx,
                    ty.fields[4usize].ty,
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).length_front)
                            }
                        }
                    },
                )?;
                wasmtime::component::Lower::linear_lower_to_flat(
                    &self.length_back,
                    cx,
                    ty.fields[5usize].ty,
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).length_back)
                            }
                        }
                    },
                )?;
                wasmtime::component::Lower::linear_lower_to_flat(
                    &self.clearing_back,
                    cx,
                    ty.fields[6usize].ty,
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).clearing_back)
                            }
                        }
                    },
                )?;
                wasmtime::component::Lower::linear_lower_to_flat(
                    &self.wheel_radius,
                    cx,
                    ty.fields[7usize].ty,
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).wheel_radius)
                            }
                        }
                    },
                )?;
                wasmtime::component::Lower::linear_lower_to_flat(
                    &self.gear_ratio_num,
                    cx,
                    ty.fields[8usize].ty,
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).gear_ratio_num)
                            }
                        }
                    },
                )?;
                wasmtime::component::Lower::linear_lower_to_flat(
                    &self.gear_ratio_den,
                    cx,
                    ty.fields[9usize].ty,
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).gear_ratio_den)
                            }
                        }
                    },
                )?;
                wasmtime::component::Lower::linear_lower_to_flat(
                    &self.front_sensors_spacing,
                    cx,
                    ty.fields[10usize].ty,
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).front_sensors_spacing)
                            }
                        }
                    },
                )?;
                wasmtime::component::Lower::linear_lower_to_flat(
                    &self.front_sensors_height,
                    cx,
                    ty.fields[11usize].ty,
                    {
                        #[allow(unused_unsafe, reason = "macro-generated code")]
                        {
                            unsafe {
                                use ::wasmtime::MaybeUninitExt;
                                let m: &mut core::mem::MaybeUninit<_> = dst;
                                m.map(|p| &raw mut (*p).front_sensors_height)
                            }
                        }
                    },
                )?;
                Ok(())
            }
            #[inline]
            fn linear_lower_to_memory<T>(
                &self,
                cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                ty: wasmtime::component::__internal::InterfaceType,
                mut offset: usize,
            ) -> wasmtime::component::__internal::anyhow::Result<()> {
                if true {
                    if !(offset
                        % (<Self as wasmtime::component::ComponentType>::ALIGN32
                            as usize) == 0)
                    {
                        ::core::panicking::panic(
                            "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                        )
                    }
                }
                let ty = match ty {
                    wasmtime::component::__internal::InterfaceType::Record(i) => {
                        &cx.types[i]
                    }
                    _ => wasmtime::component::__internal::bad_type_info(),
                };
                wasmtime::component::Lower::linear_lower_to_memory(
                    &self.name,
                    cx,
                    ty.fields[0usize].ty,
                    <wasmtime::component::__internal::String as wasmtime::component::ComponentType>::ABI
                        .next_field32_size(&mut offset),
                )?;
                wasmtime::component::Lower::linear_lower_to_memory(
                    &self.color_main,
                    cx,
                    ty.fields[1usize].ty,
                    <Color as wasmtime::component::ComponentType>::ABI
                        .next_field32_size(&mut offset),
                )?;
                wasmtime::component::Lower::linear_lower_to_memory(
                    &self.color_secondary,
                    cx,
                    ty.fields[2usize].ty,
                    <Color as wasmtime::component::ComponentType>::ABI
                        .next_field32_size(&mut offset),
                )?;
                wasmtime::component::Lower::linear_lower_to_memory(
                    &self.width_axle,
                    cx,
                    ty.fields[3usize].ty,
                    <i32 as wasmtime::component::ComponentType>::ABI
                        .next_field32_size(&mut offset),
                )?;
                wasmtime::component::Lower::linear_lower_to_memory(
                    &self.length_front,
                    cx,
                    ty.fields[4usize].ty,
                    <i32 as wasmtime::component::ComponentType>::ABI
                        .next_field32_size(&mut offset),
                )?;
                wasmtime::component::Lower::linear_lower_to_memory(
                    &self.length_back,
                    cx,
                    ty.fields[5usize].ty,
                    <i32 as wasmtime::component::ComponentType>::ABI
                        .next_field32_size(&mut offset),
                )?;
                wasmtime::component::Lower::linear_lower_to_memory(
                    &self.clearing_back,
                    cx,
                    ty.fields[6usize].ty,
                    <i32 as wasmtime::component::ComponentType>::ABI
                        .next_field32_size(&mut offset),
                )?;
                wasmtime::component::Lower::linear_lower_to_memory(
                    &self.wheel_radius,
                    cx,
                    ty.fields[7usize].ty,
                    <i32 as wasmtime::component::ComponentType>::ABI
                        .next_field32_size(&mut offset),
                )?;
                wasmtime::component::Lower::linear_lower_to_memory(
                    &self.gear_ratio_num,
                    cx,
                    ty.fields[8usize].ty,
                    <i32 as wasmtime::component::ComponentType>::ABI
                        .next_field32_size(&mut offset),
                )?;
                wasmtime::component::Lower::linear_lower_to_memory(
                    &self.gear_ratio_den,
                    cx,
                    ty.fields[9usize].ty,
                    <i32 as wasmtime::component::ComponentType>::ABI
                        .next_field32_size(&mut offset),
                )?;
                wasmtime::component::Lower::linear_lower_to_memory(
                    &self.front_sensors_spacing,
                    cx,
                    ty.fields[10usize].ty,
                    <i32 as wasmtime::component::ComponentType>::ABI
                        .next_field32_size(&mut offset),
                )?;
                wasmtime::component::Lower::linear_lower_to_memory(
                    &self.front_sensors_height,
                    cx,
                    ty.fields[11usize].ty,
                    <i32 as wasmtime::component::ComponentType>::ABI
                        .next_field32_size(&mut offset),
                )?;
                Ok(())
            }
        }
        unsafe impl wasmtime::component::Lift for Configuration {
            #[inline]
            fn linear_lift_from_flat(
                cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                ty: wasmtime::component::__internal::InterfaceType,
                src: &Self::Lower,
            ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                let ty = match ty {
                    wasmtime::component::__internal::InterfaceType::Record(i) => {
                        &cx.types[i]
                    }
                    _ => wasmtime::component::__internal::bad_type_info(),
                };
                Ok(Self {
                    name: <wasmtime::component::__internal::String as wasmtime::component::Lift>::linear_lift_from_flat(
                        cx,
                        ty.fields[0usize].ty,
                        &src.name,
                    )?,
                    color_main: <Color as wasmtime::component::Lift>::linear_lift_from_flat(
                        cx,
                        ty.fields[1usize].ty,
                        &src.color_main,
                    )?,
                    color_secondary: <Color as wasmtime::component::Lift>::linear_lift_from_flat(
                        cx,
                        ty.fields[2usize].ty,
                        &src.color_secondary,
                    )?,
                    width_axle: <i32 as wasmtime::component::Lift>::linear_lift_from_flat(
                        cx,
                        ty.fields[3usize].ty,
                        &src.width_axle,
                    )?,
                    length_front: <i32 as wasmtime::component::Lift>::linear_lift_from_flat(
                        cx,
                        ty.fields[4usize].ty,
                        &src.length_front,
                    )?,
                    length_back: <i32 as wasmtime::component::Lift>::linear_lift_from_flat(
                        cx,
                        ty.fields[5usize].ty,
                        &src.length_back,
                    )?,
                    clearing_back: <i32 as wasmtime::component::Lift>::linear_lift_from_flat(
                        cx,
                        ty.fields[6usize].ty,
                        &src.clearing_back,
                    )?,
                    wheel_radius: <i32 as wasmtime::component::Lift>::linear_lift_from_flat(
                        cx,
                        ty.fields[7usize].ty,
                        &src.wheel_radius,
                    )?,
                    gear_ratio_num: <i32 as wasmtime::component::Lift>::linear_lift_from_flat(
                        cx,
                        ty.fields[8usize].ty,
                        &src.gear_ratio_num,
                    )?,
                    gear_ratio_den: <i32 as wasmtime::component::Lift>::linear_lift_from_flat(
                        cx,
                        ty.fields[9usize].ty,
                        &src.gear_ratio_den,
                    )?,
                    front_sensors_spacing: <i32 as wasmtime::component::Lift>::linear_lift_from_flat(
                        cx,
                        ty.fields[10usize].ty,
                        &src.front_sensors_spacing,
                    )?,
                    front_sensors_height: <i32 as wasmtime::component::Lift>::linear_lift_from_flat(
                        cx,
                        ty.fields[11usize].ty,
                        &src.front_sensors_height,
                    )?,
                })
            }
            #[inline]
            fn linear_lift_from_memory(
                cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                ty: wasmtime::component::__internal::InterfaceType,
                bytes: &[u8],
            ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                let ty = match ty {
                    wasmtime::component::__internal::InterfaceType::Record(i) => {
                        &cx.types[i]
                    }
                    _ => wasmtime::component::__internal::bad_type_info(),
                };
                if true {
                    if !((bytes.as_ptr() as usize)
                        % (<Self as wasmtime::component::ComponentType>::ALIGN32
                            as usize) == 0)
                    {
                        ::core::panicking::panic(
                            "assertion failed: (bytes.as_ptr() as usize) %\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                        )
                    }
                }
                let mut offset = 0;
                Ok(Self {
                    name: <wasmtime::component::__internal::String as wasmtime::component::Lift>::linear_lift_from_memory(
                        cx,
                        ty.fields[0usize].ty,
                        &bytes[<wasmtime::component::__internal::String as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(
                                &mut offset,
                            )..][..<wasmtime::component::__internal::String as wasmtime::component::ComponentType>::SIZE32],
                    )?,
                    color_main: <Color as wasmtime::component::Lift>::linear_lift_from_memory(
                        cx,
                        ty.fields[1usize].ty,
                        &bytes[<Color as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(
                                &mut offset,
                            )..][..<Color as wasmtime::component::ComponentType>::SIZE32],
                    )?,
                    color_secondary: <Color as wasmtime::component::Lift>::linear_lift_from_memory(
                        cx,
                        ty.fields[2usize].ty,
                        &bytes[<Color as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(
                                &mut offset,
                            )..][..<Color as wasmtime::component::ComponentType>::SIZE32],
                    )?,
                    width_axle: <i32 as wasmtime::component::Lift>::linear_lift_from_memory(
                        cx,
                        ty.fields[3usize].ty,
                        &bytes[<i32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(
                                &mut offset,
                            )..][..<i32 as wasmtime::component::ComponentType>::SIZE32],
                    )?,
                    length_front: <i32 as wasmtime::component::Lift>::linear_lift_from_memory(
                        cx,
                        ty.fields[4usize].ty,
                        &bytes[<i32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(
                                &mut offset,
                            )..][..<i32 as wasmtime::component::ComponentType>::SIZE32],
                    )?,
                    length_back: <i32 as wasmtime::component::Lift>::linear_lift_from_memory(
                        cx,
                        ty.fields[5usize].ty,
                        &bytes[<i32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(
                                &mut offset,
                            )..][..<i32 as wasmtime::component::ComponentType>::SIZE32],
                    )?,
                    clearing_back: <i32 as wasmtime::component::Lift>::linear_lift_from_memory(
                        cx,
                        ty.fields[6usize].ty,
                        &bytes[<i32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(
                                &mut offset,
                            )..][..<i32 as wasmtime::component::ComponentType>::SIZE32],
                    )?,
                    wheel_radius: <i32 as wasmtime::component::Lift>::linear_lift_from_memory(
                        cx,
                        ty.fields[7usize].ty,
                        &bytes[<i32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(
                                &mut offset,
                            )..][..<i32 as wasmtime::component::ComponentType>::SIZE32],
                    )?,
                    gear_ratio_num: <i32 as wasmtime::component::Lift>::linear_lift_from_memory(
                        cx,
                        ty.fields[8usize].ty,
                        &bytes[<i32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(
                                &mut offset,
                            )..][..<i32 as wasmtime::component::ComponentType>::SIZE32],
                    )?,
                    gear_ratio_den: <i32 as wasmtime::component::Lift>::linear_lift_from_memory(
                        cx,
                        ty.fields[9usize].ty,
                        &bytes[<i32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(
                                &mut offset,
                            )..][..<i32 as wasmtime::component::ComponentType>::SIZE32],
                    )?,
                    front_sensors_spacing: <i32 as wasmtime::component::Lift>::linear_lift_from_memory(
                        cx,
                        ty.fields[10usize].ty,
                        &bytes[<i32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(
                                &mut offset,
                            )..][..<i32 as wasmtime::component::ComponentType>::SIZE32],
                    )?,
                    front_sensors_height: <i32 as wasmtime::component::Lift>::linear_lift_from_memory(
                        cx,
                        ty.fields[11usize].ty,
                        &bytes[<i32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(
                                &mut offset,
                            )..][..<i32 as wasmtime::component::ComponentType>::SIZE32],
                    )?,
                })
            }
        }
        const _: () = {
            #[doc(hidden)]
            #[repr(C)]
            pub struct LowerConfiguration<
                T0: Copy,
                T1: Copy,
                T2: Copy,
                T3: Copy,
                T4: Copy,
                T5: Copy,
                T6: Copy,
                T7: Copy,
                T8: Copy,
                T9: Copy,
                T10: Copy,
                T11: Copy,
            > {
                name: T0,
                color_main: T1,
                color_secondary: T2,
                width_axle: T3,
                length_front: T4,
                length_back: T5,
                clearing_back: T6,
                wheel_radius: T7,
                gear_ratio_num: T8,
                gear_ratio_den: T9,
                front_sensors_spacing: T10,
                front_sensors_height: T11,
                _align: [wasmtime::ValRaw; 0],
            }
            #[automatically_derived]
            impl<
                T0: ::core::clone::Clone + Copy,
                T1: ::core::clone::Clone + Copy,
                T2: ::core::clone::Clone + Copy,
                T3: ::core::clone::Clone + Copy,
                T4: ::core::clone::Clone + Copy,
                T5: ::core::clone::Clone + Copy,
                T6: ::core::clone::Clone + Copy,
                T7: ::core::clone::Clone + Copy,
                T8: ::core::clone::Clone + Copy,
                T9: ::core::clone::Clone + Copy,
                T10: ::core::clone::Clone + Copy,
                T11: ::core::clone::Clone + Copy,
            > ::core::clone::Clone
            for LowerConfiguration<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
                #[inline]
                fn clone(
                    &self,
                ) -> LowerConfiguration<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                > {
                    LowerConfiguration {
                        name: ::core::clone::Clone::clone(&self.name),
                        color_main: ::core::clone::Clone::clone(&self.color_main),
                        color_secondary: ::core::clone::Clone::clone(
                            &self.color_secondary,
                        ),
                        width_axle: ::core::clone::Clone::clone(&self.width_axle),
                        length_front: ::core::clone::Clone::clone(&self.length_front),
                        length_back: ::core::clone::Clone::clone(&self.length_back),
                        clearing_back: ::core::clone::Clone::clone(&self.clearing_back),
                        wheel_radius: ::core::clone::Clone::clone(&self.wheel_radius),
                        gear_ratio_num: ::core::clone::Clone::clone(
                            &self.gear_ratio_num,
                        ),
                        gear_ratio_den: ::core::clone::Clone::clone(
                            &self.gear_ratio_den,
                        ),
                        front_sensors_spacing: ::core::clone::Clone::clone(
                            &self.front_sensors_spacing,
                        ),
                        front_sensors_height: ::core::clone::Clone::clone(
                            &self.front_sensors_height,
                        ),
                        _align: ::core::clone::Clone::clone(&self._align),
                    }
                }
            }
            #[automatically_derived]
            impl<
                T0: ::core::marker::Copy + Copy,
                T1: ::core::marker::Copy + Copy,
                T2: ::core::marker::Copy + Copy,
                T3: ::core::marker::Copy + Copy,
                T4: ::core::marker::Copy + Copy,
                T5: ::core::marker::Copy + Copy,
                T6: ::core::marker::Copy + Copy,
                T7: ::core::marker::Copy + Copy,
                T8: ::core::marker::Copy + Copy,
                T9: ::core::marker::Copy + Copy,
                T10: ::core::marker::Copy + Copy,
                T11: ::core::marker::Copy + Copy,
            > ::core::marker::Copy
            for LowerConfiguration<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {}
            unsafe impl wasmtime::component::ComponentType for Configuration {
                type Lower = LowerConfiguration<
                    <wasmtime::component::__internal::String as wasmtime::component::ComponentType>::Lower,
                    <Color as wasmtime::component::ComponentType>::Lower,
                    <Color as wasmtime::component::ComponentType>::Lower,
                    <i32 as wasmtime::component::ComponentType>::Lower,
                    <i32 as wasmtime::component::ComponentType>::Lower,
                    <i32 as wasmtime::component::ComponentType>::Lower,
                    <i32 as wasmtime::component::ComponentType>::Lower,
                    <i32 as wasmtime::component::ComponentType>::Lower,
                    <i32 as wasmtime::component::ComponentType>::Lower,
                    <i32 as wasmtime::component::ComponentType>::Lower,
                    <i32 as wasmtime::component::ComponentType>::Lower,
                    <i32 as wasmtime::component::ComponentType>::Lower,
                >;
                const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                    &[
                        <wasmtime::component::__internal::String as wasmtime::component::ComponentType>::ABI,
                        <Color as wasmtime::component::ComponentType>::ABI,
                        <Color as wasmtime::component::ComponentType>::ABI,
                        <i32 as wasmtime::component::ComponentType>::ABI,
                        <i32 as wasmtime::component::ComponentType>::ABI,
                        <i32 as wasmtime::component::ComponentType>::ABI,
                        <i32 as wasmtime::component::ComponentType>::ABI,
                        <i32 as wasmtime::component::ComponentType>::ABI,
                        <i32 as wasmtime::component::ComponentType>::ABI,
                        <i32 as wasmtime::component::ComponentType>::ABI,
                        <i32 as wasmtime::component::ComponentType>::ABI,
                        <i32 as wasmtime::component::ComponentType>::ABI,
                    ],
                );
                #[inline]
                fn typecheck(
                    ty: &wasmtime::component::__internal::InterfaceType,
                    types: &wasmtime::component::__internal::InstanceType<'_>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    wasmtime::component::__internal::typecheck_record(
                        ty,
                        types,
                        &[
                            (
                                "name",
                                <wasmtime::component::__internal::String as wasmtime::component::ComponentType>::typecheck,
                            ),
                            (
                                "color-main",
                                <Color as wasmtime::component::ComponentType>::typecheck,
                            ),
                            (
                                "color-secondary",
                                <Color as wasmtime::component::ComponentType>::typecheck,
                            ),
                            (
                                "width-axle",
                                <i32 as wasmtime::component::ComponentType>::typecheck,
                            ),
                            (
                                "length-front",
                                <i32 as wasmtime::component::ComponentType>::typecheck,
                            ),
                            (
                                "length-back",
                                <i32 as wasmtime::component::ComponentType>::typecheck,
                            ),
                            (
                                "clearing-back",
                                <i32 as wasmtime::component::ComponentType>::typecheck,
                            ),
                            (
                                "wheel-radius",
                                <i32 as wasmtime::component::ComponentType>::typecheck,
                            ),
                            (
                                "gear-ratio-num",
                                <i32 as wasmtime::component::ComponentType>::typecheck,
                            ),
                            (
                                "gear-ratio-den",
                                <i32 as wasmtime::component::ComponentType>::typecheck,
                            ),
                            (
                                "front-sensors-spacing",
                                <i32 as wasmtime::component::ComponentType>::typecheck,
                            ),
                            (
                                "front-sensors-height",
                                <i32 as wasmtime::component::ComponentType>::typecheck,
                            ),
                        ],
                    )
                }
            }
        };
        impl core::fmt::Debug for Configuration {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                f.debug_struct("Configuration")
                    .field("name", &self.name)
                    .field("color-main", &self.color_main)
                    .field("color-secondary", &self.color_secondary)
                    .field("width-axle", &self.width_axle)
                    .field("length-front", &self.length_front)
                    .field("length-back", &self.length_back)
                    .field("clearing-back", &self.clearing_back)
                    .field("wheel-radius", &self.wheel_radius)
                    .field("gear-ratio-num", &self.gear_ratio_num)
                    .field("gear-ratio-den", &self.gear_ratio_den)
                    .field("front-sensors-spacing", &self.front_sensors_spacing)
                    .field("front-sensors-height", &self.front_sensors_height)
                    .finish()
            }
        }
        const _: () = {
            if !(52 == <Configuration as wasmtime::component::ComponentType>::SIZE32) {
                ::core::panicking::panic(
                    "assertion failed: 52 == <Configuration as wasmtime::component::ComponentType>::SIZE32",
                )
            }
            if !(4 == <Configuration as wasmtime::component::ComponentType>::ALIGN32) {
                ::core::panicking::panic(
                    "assertion failed: 4 == <Configuration as wasmtime::component::ComponentType>::ALIGN32",
                )
            }
        };
        pub struct Guest {
            setup: wasmtime::component::Func,
            run: wasmtime::component::Func,
        }
        pub struct GuestIndices {
            setup: wasmtime::component::ComponentExportIndex,
            run: wasmtime::component::ComponentExportIndex,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for GuestIndices {
            #[inline]
            fn clone(&self) -> GuestIndices {
                GuestIndices {
                    setup: ::core::clone::Clone::clone(&self.setup),
                    run: ::core::clone::Clone::clone(&self.run),
                }
            }
        }
        impl GuestIndices {
            /// Constructor for [`GuestIndices`] which takes a
            /// [`Component`](wasmtime::component::Component) as input and can be executed
            /// before instantiation.
            ///
            /// This constructor can be used to front-load string lookups to find exports
            /// within a component.
            pub fn new<_T>(
                _instance_pre: &wasmtime::component::InstancePre<_T>,
            ) -> wasmtime::Result<GuestIndices> {
                let instance = _instance_pre
                    .component()
                    .get_export_index(None, "robot")
                    .ok_or_else(|| ::anyhow::__private::must_use({
                        let error = ::anyhow::__private::format_err(
                            format_args!("no exported instance named `robot`"),
                        );
                        error
                    }))?;
                let mut lookup = move |name| {
                    _instance_pre
                        .component()
                        .get_export_index(Some(&instance), name)
                        .ok_or_else(|| {
                            ::anyhow::__private::must_use({
                                let error = ::anyhow::__private::format_err(
                                    format_args!(
                                        "instance export `robot` does not have export `{0}`",
                                        name,
                                    ),
                                );
                                error
                            })
                        })
                };
                let _ = &mut lookup;
                let setup = lookup("setup")?;
                let run = lookup("run")?;
                Ok(GuestIndices { setup, run })
            }
            pub fn load(
                &self,
                mut store: impl wasmtime::AsContextMut,
                instance: &wasmtime::component::Instance,
            ) -> wasmtime::Result<Guest> {
                let _instance = instance;
                let _instance_pre = _instance.instance_pre(&store);
                let _instance_type = _instance_pre.instance_type();
                let mut store = store.as_context_mut();
                let _ = &mut store;
                let setup = *_instance
                    .get_typed_func::<(), (Configuration,)>(&mut store, &self.setup)?
                    .func();
                let run = *_instance
                    .get_typed_func::<(), ()>(&mut store, &self.run)?
                    .func();
                Ok(Guest { setup, run })
            }
        }
        impl Guest {
            pub fn call_setup<S: wasmtime::AsContextMut>(
                &self,
                mut store: S,
            ) -> wasmtime::Result<Configuration> {
                let callee = unsafe {
                    wasmtime::component::TypedFunc::<
                        (),
                        (Configuration,),
                    >::new_unchecked(self.setup)
                };
                let (ret0,) = callee.call(store.as_context_mut(), ())?;
                callee.post_return(store.as_context_mut())?;
                Ok(ret0)
            }
            pub fn call_run<S: wasmtime::AsContextMut>(
                &self,
                mut store: S,
            ) -> wasmtime::Result<()> {
                let callee = unsafe {
                    wasmtime::component::TypedFunc::<(), ()>::new_unchecked(self.run)
                };
                let () = callee.call(store.as_context_mut(), ())?;
                callee.post_return(store.as_context_mut())?;
                Ok(())
            }
        }
    }
}
const _: &str = "package component:line-follower-robot;\n\nworld line-follower-robot {\n    import sensors: interface {\n        enum read-error {\n            index-out-of-range,\n            invalid-handle-type,\n            invalid-handle,\n        }\n\n        type time-us = u32;\n\n        current-time: func() -> time-us;\n        sleep-blocking-for: func(us: time-us);\n        sleep-blocking-until: func(us: time-us);\n\n        enum sensor-kind {\n            line,\n            imu,\n            angle,\n        }\n        record sensor-index-range {\n            start: u8,\n            count: u8,\n        }\n        type sensor-value = s16;\n        type sensor-values = list<sensor-value>;\n\n        read-sensor-blocking: func(sensor: sensor-kind, indexes: sensor-index-range) -> result<sensor-values, read-error>;\n\n        type future-handle = u32;\n        variant async-void-result {\n            blocked,\n            ready,\n        }\n        variant async-sensor-result {\n            blocked,\n            ready(sensor-values),\n        }\n\n        sleep-async-for: func(us: time-us) -> future-handle;\n        sleep-async-until: func(us: time-us) -> future-handle;\n        read-sensor-async: func(sensor: sensor-kind, sensor-index-range: sensor-index-range) -> future-handle;\n\n        poll-timer: func(handle: future-handle) -> result<async-void-result, read-error>;\n        poll-sensor: func(handle: future-handle) -> result<async-sensor-result, read-error>;\n        forget-handle: func(handle: future-handle);\n    }\n\n    import motors: interface {\n        type motor-power = s16;\n        set-power: func(left: motor-power, right: motor-power);\n    }\n\n    export robot: interface {\n        record color {\n            r: u8,\n            g: u8,\n            b: u8,\n        }\n\n        record configuration {\n            name: string,\n            color-main: color,\n            color-secondary: color,\n\n            width-axle: s32,\n            length-front: s32,\n            length-back: s32,\n            clearing-back: s32,\n\n            wheel-radius: s32,\n            gear-ratio-num: s32,\n            gear-ratio-den: s32,\n\n            front-sensors-spacing: s32,\n            front-sensors-height: s32,\n        }\n\n        setup: func() -> configuration;\n        run: func();\n    }\n}\n";
pub struct BotHost {}
impl sensors::Host for BotHost {
    fn current_time(&mut self) -> TimeUs {
        0
    }
    fn sleep_blocking_for(&mut self, us: TimeUs) -> () {
        std::thread::sleep(std::time::Duration::from_micros(us as u64));
    }
    fn sleep_blocking_until(&mut self, _us: TimeUs) -> () {}
    fn read_sensor_blocking(
        &mut self,
        _sensor: SensorKind,
        indexes: SensorIndexRange,
    ) -> Result<SensorValues, ReadError> {
        Ok(::alloc::vec::from_elem(0, indexes.count as usize))
    }
    fn sleep_async_for(&mut self, _us: TimeUs) -> FutureHandle {
        0
    }
    fn sleep_async_until(&mut self, _us: TimeUs) -> FutureHandle {
        0
    }
    fn read_sensor_async(
        &mut self,
        _sensor: SensorKind,
        _sensor_index_range: SensorIndexRange,
    ) -> FutureHandle {
        0
    }
    fn poll_timer(
        &mut self,
        _handle: FutureHandle,
    ) -> Result<AsyncVoidResult, ReadError> {
        Ok(AsyncVoidResult::Blocked)
    }
    fn poll_sensor(
        &mut self,
        _handle: FutureHandle,
    ) -> Result<AsyncSensorResult, ReadError> {
        Ok(AsyncSensorResult::Blocked)
    }
    fn forget_handle(&mut self, _handle: FutureHandle) -> () {}
}
impl motors::Host for BotHost {
    fn set_power(&mut self, _left: MotorPower, _right: MotorPower) -> () {}
}
fn main() -> wasmtime::Result<()> {
    let engine = wasmtime::Engine::default();
    let mut store = wasmtime::Store::new(&engine, ());
    let bytes = std::fs::read(
        "sample-robot-code/target/wasm32-wasip1/release/line_follower_robot.wasm",
    )?;
    let component = wasmtime::component::Component::new(&engine, bytes)?;
    let mut linker = wasmtime::component::Linker::new(&engine);
    linker.root().func_wrap("name", |_store, _params: ()| Ok((String::from("Alice"),)))?;
    let instance = linker.instantiate(&mut store, &component)?;
    let func = instance.get_func(&mut store, "greet").expect("greet export not found");
    let mut result = [wasmtime::component::Val::String("".into())];
    func.call(&mut store, &[], &mut result)?;
    {
        ::std::io::_print(format_args!("Greeting: {0:?}\n", result));
    };
    Ok(())
}
